// <auto-generated />

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using AngleSharp.Text;
using Azure;
using Azure.AI.OpenAI;
using Azure.Core.Pipeline;
using Azure.Core;
using Microsoft.SemanticKernel.AI;
using Microsoft.SemanticKernel.AI.ChatCompletion;
using Microsoft.SemanticKernel.AI.Embeddings;
using Microsoft.SemanticKernel.AI.TextCompletion;
using Microsoft.SemanticKernel.Connectors.AI.OpenAI.ChatCompletion;
using Microsoft.SemanticKernel.Orchestration;
using System.Net.Http;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel.Connectors.AI.OpenAI.AzureSdk;

namespace FantasyCopilot.Services;

internal abstract class ProxyOpenAIClientBase
{
    private const int MaxResultsPerPrompt = 128;

    // Prevent external inheritors
    private protected ProxyOpenAIClientBase(
        string modelId,
        string apiKey,
        string proxyEndpoint,
        string organization = null,
        HttpClient httpClient = null,
        ILogger logger = null)
    {
        Verify.NotNullOrWhiteSpace(modelId);
        Verify.NotNullOrWhiteSpace(apiKey);

        this.ModelId = modelId;

        var options = new OpenAIClientOptions();
        if (httpClient != null)
        {
            options.Transport = new HttpClientTransport(httpClient);
        }

        if (!string.IsNullOrWhiteSpace(organization))
        {
            options.AddPolicy(new ProxyAddHeaderRequestPolicy("OpenAI-Organization", organization!), HttpPipelinePosition.PerCall);
        }

        Client = new OpenAIClient(apiKey, options);

        // A hack way to directly modify the corresponding endpoint.
        var prop = Client.GetType().GetField("_endpoint", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
        prop.SetValue(Client, new Uri(proxyEndpoint));
    }

    /// <summary>
    /// Model Id or Deployment Name.
    /// </summary>
    private protected string ModelId { get; set; } = string.Empty;

    /// <summary>
    /// OpenAI / Azure OpenAI Client.
    /// </summary>
    private protected OpenAIClient Client { get; }

    /// <summary>
    /// Creates completions for the prompt and settings.
    /// </summary>
    /// <param name="text">The prompt to complete.</param>
    /// <param name="requestSettings">Request settings for the completion API.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Completions generated by the remote model.</returns>
    private protected async Task<IReadOnlyList<ITextCompletionResult>> InternalGetTextResultsAsync(
        string text,
        CompleteRequestSettings requestSettings,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(requestSettings);

        ValidateMaxTokens(requestSettings.MaxTokens);
        var options = CreateCompletionsOptions(text, requestSettings);

        var response = await RunRequestAsync<Response<Completions>>(
            () => this.Client.GetCompletionsAsync(this.ModelId, options, cancellationToken)).ConfigureAwait(false)
            ?? throw new ProxyOpenAIInvalidResponseException<Completions>(null, "Text completions null response");

        var responseData = response.Value;

        return responseData.Choices.Count == 0
            ? throw new ProxyOpenAIInvalidResponseException<Completions>(responseData, "Text completions not found")
            : responseData.Choices.Select(choice => new ProxyTextCompletionResult(responseData, choice)).ToList();
    }

    /// <summary>
    /// Creates completions streams for the prompt and settings.
    /// </summary>
    /// <param name="text">The prompt to complete.</param>
    /// <param name="requestSettings">Request settings for the completion API</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>Stream the completions generated by the remote model</returns>
    private protected async IAsyncEnumerable<ProxyTextCompletionStreamingResult> InternalGetTextStreamingResultsAsync(
        string text,
        CompleteRequestSettings requestSettings,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(requestSettings);

        ValidateMaxTokens(requestSettings.MaxTokens);
        var options = CreateCompletionsOptions(text, requestSettings);

        var response = await RunRequestAsync<Response<StreamingCompletions>>(
            () => this.Client.GetCompletionsStreamingAsync(this.ModelId, options, cancellationToken)).ConfigureAwait(false);

        using var streamingChatCompletions = response.Value;
        await foreach (var choice in streamingChatCompletions.GetChoicesStreaming(cancellationToken))
        {
            yield return new ProxyTextCompletionStreamingResult(streamingChatCompletions, choice);
        }
    }

    /// <summary>
    /// Generates an embedding from the given <paramref name="data"/>.
    /// </summary>
    /// <param name="data">List of strings to generate embeddings for.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests. The default is <see cref="CancellationToken.None"/>.</param>
    /// <returns>List of embeddings.</returns>
    private protected async Task<IList<Embedding<float>>> InternalGetEmbeddingsAsync(
        IList<string> data,
        CancellationToken cancellationToken = default)
    {
        var result = new List<Embedding<float>>();
        foreach (var text in data)
        {
            var options = new EmbeddingsOptions(text);

            var response = await RunRequestAsync<Response<Embeddings>>(
                () => this.Client.GetEmbeddingsAsync(this.ModelId, options, cancellationToken)).ConfigureAwait(false)
                ?? throw new ProxyOpenAIInvalidResponseException<Embeddings>(null, "Text embedding null response");

            if (response.Value.Data.Count == 0)
            {
                throw new ProxyOpenAIInvalidResponseException<Embeddings>(response.Value, "Text embedding not found");
            }

            EmbeddingItem x = response.Value.Data[0];

            result.Add(new Embedding<float>(x.Embedding, transferOwnership: true));
        }

        return result;
    }

    /// <summary>
    /// Generate a new chat message
    /// </summary>
    /// <param name="chat">Chat history</param>
    /// <param name="chatSettings">AI request settings</param>
    /// <param name="cancellationToken">Async cancellation token</param>
    /// <returns>Generated chat message in string format</returns>
    private protected async Task<IReadOnlyList<IChatResult>> InternalGetChatResultsAsync(
        ChatHistory chat,
        ChatRequestSettings chatSettings,
        CancellationToken cancellationToken = default)
    {
        Verify.NotNull(chat);
        chatSettings ??= new();

        ValidateMaxTokens(chatSettings.MaxTokens);
        var chatOptions = CreateChatCompletionsOptions(chatSettings, chat);

        Response<ChatCompletions> response = await RunRequestAsync<Response<ChatCompletions>>(
            () => this.Client.GetChatCompletionsAsync(this.ModelId, chatOptions, cancellationToken)).ConfigureAwait(false);

        if (response == null)
        {
            throw new ProxyOpenAIInvalidResponseException<ChatCompletions>(null, "Chat completions null response");
        }

        if (response.Value.Choices.Count == 0)
        {
            throw new ProxyOpenAIInvalidResponseException<ChatCompletions>(response.Value, "Chat completions not found");
        }

        return response.Value.Choices.Select(chatChoice => new ProxyChatResult(response.Value, chatChoice)).ToList();
    }

    /// <summary>
    /// Generate a new chat message stream
    /// </summary>
    /// <param name="chat">Chat history</param>
    /// <param name="requestSettings">AI request settings</param>
    /// <param name="cancellationToken">Async cancellation token</param>
    /// <returns>Streaming of generated chat message in string format</returns>
    private protected async IAsyncEnumerable<IChatStreamingResult> InternalGetChatStreamingResultsAsync(
        IEnumerable<ChatMessageBase> chat,
        ChatRequestSettings requestSettings,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        Verify.NotNull(chat);
        requestSettings ??= new();

        ValidateMaxTokens(requestSettings.MaxTokens);

        var options = CreateChatCompletionsOptions(requestSettings, chat);

        Response<StreamingChatCompletions> response = await RunRequestAsync<Response<StreamingChatCompletions>>(
            () => this.Client.GetChatCompletionsStreamingAsync(this.ModelId, options, cancellationToken)).ConfigureAwait(false);

        if (response is null)
        {
            throw new ProxyOpenAIInvalidResponseException<StreamingChatCompletions>(null, "Chat completions null response");
        }

        using StreamingChatCompletions streamingChatCompletions = response.Value;

        var choices = await response.Value.GetChoicesStreaming(cancellationToken).ToListAsync(cancellationToken).ConfigureAwait(false);
        if (choices.Count == 0)
        {
            throw new ProxyOpenAIInvalidResponseException<StreamingChatCompletions>(streamingChatCompletions, "Streaming chat completions not found");
        }

        foreach (StreamingChatChoice choice in choices)
        {
            yield return new ProxyChatStreamingResult(response.Value, choice);
        }
    }

    /// <summary>
    /// Create a new empty chat instance
    /// </summary>
    /// <param name="instructions">Optional chat instructions for the AI service</param>
    /// <returns>Chat object</returns>
    private protected static OpenAIChatHistory InternalCreateNewChat(string instructions = null)
    {
        return new OpenAIChatHistory(instructions);
    }

    private protected async Task<IReadOnlyList<ITextCompletionResult>> InternalGetChatResultsAsTextAsync(
        string text,
        CompleteRequestSettings textSettings,
        CancellationToken cancellationToken = default)
    {
        textSettings ??= new();
        ChatHistory chat = PrepareChatHistory(text, textSettings, out ChatRequestSettings chatSettings);

        return (await this.InternalGetChatResultsAsync(chat, chatSettings, cancellationToken).ConfigureAwait(false))
            .OfType<ITextCompletionResult>()
            .ToList();
    }

    private protected async IAsyncEnumerable<ITextCompletionStreamingResult> InternalGetChatStreamingResultsAsTextAsync(
        string text,
        CompleteRequestSettings textSettings,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ChatHistory chat = PrepareChatHistory(text, textSettings, out ChatRequestSettings chatSettings);

        await foreach (var chatCompletionStreamingResult in this.InternalGetChatStreamingResultsAsync(chat, chatSettings, cancellationToken))
        {
            yield return (ITextCompletionStreamingResult)chatCompletionStreamingResult;
        }
    }

    private static OpenAIChatHistory PrepareChatHistory(string text, CompleteRequestSettings requestSettings, out ChatRequestSettings settings)
    {
        requestSettings ??= new();
        var chat = InternalCreateNewChat();
        chat.AddUserMessage(text);
        settings = new ChatRequestSettings
        {
            MaxTokens = requestSettings.MaxTokens,
            Temperature = requestSettings.Temperature,
            TopP = requestSettings.TopP,
            PresencePenalty = requestSettings.PresencePenalty,
            FrequencyPenalty = requestSettings.FrequencyPenalty,
            StopSequences = requestSettings.StopSequences,
        };
        return chat;
    }

    private static CompletionsOptions CreateCompletionsOptions(string text, CompleteRequestSettings requestSettings)
    {
        if (requestSettings.ResultsPerPrompt is < 1 or > MaxResultsPerPrompt)
        {
            throw new ArgumentOutOfRangeException($"{nameof(requestSettings)}.{nameof(requestSettings.ResultsPerPrompt)}", requestSettings.ResultsPerPrompt, $"The value must be in range between 1 and {MaxResultsPerPrompt}, inclusive.");
        }

        var options = new CompletionsOptions
        {
            Prompts = { text.NormalizeLineEndings() },
            MaxTokens = requestSettings.MaxTokens,
            Temperature = (float?)requestSettings.Temperature,
            NucleusSamplingFactor = (float?)requestSettings.TopP,
            FrequencyPenalty = (float?)requestSettings.FrequencyPenalty,
            PresencePenalty = (float?)requestSettings.PresencePenalty,
            Echo = false,
            ChoicesPerPrompt = requestSettings.ResultsPerPrompt,
            GenerationSampleCount = requestSettings.ResultsPerPrompt,
            LogProbabilityCount = null,
            User = null,
        };

        if (requestSettings.StopSequences is { Count: > 0 })
        {
            foreach (var s in requestSettings.StopSequences)
            {
                options.StopSequences.Add(s);
            }
        }

        return options;
    }

    private static ChatCompletionsOptions CreateChatCompletionsOptions(ChatRequestSettings requestSettings, IEnumerable<ChatMessageBase> chatHistory)
    {
        if (requestSettings.ResultsPerPrompt is < 1 or > MaxResultsPerPrompt)
        {
            throw new ArgumentOutOfRangeException($"{nameof(requestSettings)}.{nameof(requestSettings.ResultsPerPrompt)}", requestSettings.ResultsPerPrompt, $"The value must be in range between 1 and {MaxResultsPerPrompt}, inclusive.");
        }

        var options = new ChatCompletionsOptions
        {
            MaxTokens = requestSettings.MaxTokens,
            Temperature = (float?)requestSettings.Temperature,
            NucleusSamplingFactor = (float?)requestSettings.TopP,
            FrequencyPenalty = (float?)requestSettings.FrequencyPenalty,
            PresencePenalty = (float?)requestSettings.PresencePenalty,
            ChoicesPerPrompt = requestSettings.ResultsPerPrompt
        };

        if (requestSettings.StopSequences is { Count: > 0 })
        {
            foreach (var s in requestSettings.StopSequences)
            {
                options.StopSequences.Add(s);
            }
        }

        foreach (var message in chatHistory)
        {
            var validRole = GetValidChatRole(message.Role);
            options.Messages.Add(new ChatMessage(validRole, message.Content));
        }

        return options;
    }

    private static ChatRole GetValidChatRole(AuthorRole role)
    {
        var validRole = new ChatRole(role.Label);

        if (validRole != ChatRole.User &&
            validRole != ChatRole.System &&
            validRole != ChatRole.Assistant)
        {
            throw new ArgumentException($"Invalid chat message author role: {role}");
        }

        return validRole;
    }

    private static void ValidateMaxTokens(int maxTokens)
    {
        if (maxTokens < 1)
        {
            throw new AIException(
                AIException.ErrorCodes.InvalidRequest,
                $"MaxTokens {maxTokens} is not valid, the value must be greater than zero");
        }
    }

    private static TokenCredential CreateDelegatedToken(string token)
    {
        var accessToken = new AccessToken(token, DateTimeOffset.Now.AddDays(180));
        return DelegatedTokenCredential.Create((_, _) => accessToken);
    }

    private static async Task<T> RunRequestAsync<T>(Func<Task<T>> request)
    {
        try
        {
            return await request.Invoke().ConfigureAwait(false);
        }
        catch (RequestFailedException e)
        {
            switch (e.Status)
            {
                case (int)HttpStatusCodeType.BadRequest:
                case (int)HttpStatusCodeType.MethodNotAllowed:
                case (int)HttpStatusCodeType.NotFound:
                case (int)HttpStatusCodeType.NotAcceptable:
                case (int)HttpStatusCodeType.Conflict:
                case (int)HttpStatusCodeType.Gone:
                case (int)HttpStatusCodeType.LengthRequired:
                case (int)HttpStatusCodeType.PreconditionFailed:
                case (int)HttpStatusCodeType.RequestEntityTooLarge:
                case (int)HttpStatusCodeType.RequestUriTooLong:
                case (int)HttpStatusCodeType.UnsupportedMediaType:
                case (int)HttpStatusCodeType.RequestedRangeNotSatisfiable:
                case (int)HttpStatusCodeType.ExpectationFailed:
                case (int)HttpStatusCodeType.HttpVersionNotSupported:
                case (int)HttpStatusCodeType.UpgradeRequired:
                case (int)HttpStatusCodeType.MisdirectedRequest:
                case (int)HttpStatusCodeType.UnprocessableEntity:
                case (int)HttpStatusCodeType.Locked:
                case (int)HttpStatusCodeType.FailedDependency:
                case (int)HttpStatusCodeType.PreconditionRequired:
                case (int)HttpStatusCodeType.RequestHeaderFieldsTooLarge:
                    throw new AIException(
                        AIException.ErrorCodes.InvalidRequest,
                        $"The request is not valid, HTTP status: {e.Status}",
                        e.Message, e);

                case (int)HttpStatusCodeType.Unauthorized:
                case (int)HttpStatusCodeType.Forbidden:
                case (int)HttpStatusCodeType.ProxyAuthenticationRequired:
                case (int)HttpStatusCodeType.UnavailableForLegalReasons:
                case (int)HttpStatusCodeType.NetworkAuthenticationRequired:
                    throw new AIException(
                        AIException.ErrorCodes.AccessDenied,
                        $"The request is not authorized, HTTP status: {e.Status}",
                        e.Message, e);

                case (int)HttpStatusCodeType.RequestTimeout:
                    throw new AIException(
                        AIException.ErrorCodes.RequestTimeout,
                        $"The request timed out, HTTP status: {e.Status}");

                case (int)HttpStatusCodeType.TooManyRequests:
                    throw new AIException(
                        AIException.ErrorCodes.Throttling,
                        $"Too many requests, HTTP status: {e.Status}",
                        e.Message, e);

                case (int)HttpStatusCodeType.InternalServerError:
                case (int)HttpStatusCodeType.NotImplemented:
                case (int)HttpStatusCodeType.BadGateway:
                case (int)HttpStatusCodeType.ServiceUnavailable:
                case (int)HttpStatusCodeType.GatewayTimeout:
                case (int)HttpStatusCodeType.InsufficientStorage:
                    throw new AIException(
                        AIException.ErrorCodes.ServiceError,
                        $"The service failed to process the request, HTTP status:{e.Status}",
                        e.Message, e);

                default:
                    throw new AIException(
                        AIException.ErrorCodes.UnknownError,
                        $"Unexpected HTTP response, status: {e.Status}",
                        e.Message, e);
            }
        }
        catch (Exception e) when (e is not AIException)
        {
            throw new AIException(
                AIException.ErrorCodes.UnknownError,
                $"Something went wrong: {e.Message}", e);
        }
    }

    internal sealed class ProxyOpenAIInvalidResponseException<T> : AIException
    {
        public ProxyOpenAIInvalidResponseException(T responseData, string message = null)
            : base(ErrorCodes.InvalidResponseContent, message)
            => ResponseData = responseData;

        public T ResponseData { get; }
    }

    internal sealed class ProxyChatStreamingResult : IChatStreamingResult, ITextCompletionStreamingResult
    {
        private readonly ModelResult _modelResult;
        private readonly StreamingChatChoice _choice;

        public ProxyChatStreamingResult(StreamingChatCompletions resultData, StreamingChatChoice choice)
        {
            Verify.NotNull(choice);
            this._modelResult = new ModelResult(resultData);
            this._choice = choice;
        }

        public ModelResult ModelResult => this._modelResult;

        /// <inheritdoc/>
        public async Task<ChatMessageBase> GetChatMessageAsync(CancellationToken cancellationToken = default)
        {
            var chatMessage = await this._choice.GetMessageStreaming(cancellationToken)
                                                    .LastOrDefaultAsync(cancellationToken)
                                                    .ConfigureAwait(false);

            if (chatMessage is null)
            {
                throw new AIException(AIException.ErrorCodes.UnknownError, "Unable to get chat message from stream");
            }

            return new SKChatMessage(chatMessage);
        }

        /// <inheritdoc/>
        public async IAsyncEnumerable<ChatMessageBase> GetStreamingChatMessageAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
        {
            await foreach (var message in this._choice.GetMessageStreaming(cancellationToken))
            {
                yield return new SKChatMessage(message);
            }
        }

        /// <inheritdoc/>
        public async Task<string> GetCompletionAsync(CancellationToken cancellationToken = default)
        {
            return (await this.GetChatMessageAsync(cancellationToken).ConfigureAwait(false)).Content;
        }

        /// <inheritdoc/>
        public async IAsyncEnumerable<string> GetCompletionStreamingAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
        {
            await foreach (var result in this.GetStreamingChatMessageAsync(cancellationToken).ConfigureAwait(false))
            {
                yield return result.Content;
            }
        }
    }

    /// <summary>
    /// Helper class to inject headers into Azure SDK HTTP pipeline
    /// </summary>
    internal sealed class ProxyAddHeaderRequestPolicy : HttpPipelineSynchronousPolicy
    {
        private readonly string _headerName;
        private readonly string _headerValue;

        public ProxyAddHeaderRequestPolicy(string headerName, string headerValue)
        {
            this._headerName = headerName;
            this._headerValue = headerValue;
        }

        public override void OnSendingRequest(HttpMessage message)
        {
            message.Request.Headers.Add(this._headerName, this._headerValue);
        }
    }

    internal sealed class ProxyChatResult : IChatResult, ITextCompletionResult
    {
        private readonly ModelResult _modelResult;
        private readonly ChatChoice _choice;

        public ProxyChatResult(ChatCompletions resultData, ChatChoice choice)
        {
            Verify.NotNull(choice);
            this._choice = choice;
            this._modelResult = new ModelResult(resultData);
        }

        public ModelResult ModelResult => this._modelResult;

        public Task<ChatMessageBase> GetChatMessageAsync(CancellationToken cancellationToken = default)
            => Task.FromResult<ChatMessageBase>(new SKChatMessage(this._choice.Message));

        public Task<string> GetCompletionAsync(CancellationToken cancellationToken = default)
        {
            return Task.FromResult(this._choice.Message.Content);
        }
    }

    internal sealed class ProxyTextCompletionStreamingResult : ITextCompletionStreamingResult
    {
        private readonly ModelResult _modelResult;
        private readonly StreamingChoice _choice;

        public ModelResult ModelResult => this._modelResult;

        public ProxyTextCompletionStreamingResult(StreamingCompletions resultData, StreamingChoice choice)
        {
            this._modelResult = new ModelResult(resultData);
            this._choice = choice;
        }

        public async Task<string> GetCompletionAsync(CancellationToken cancellationToken = default)
        {
            var fullMessage = new StringBuilder();
            await foreach (var message in this._choice.GetTextStreaming(cancellationToken).ConfigureAwait(false))
            {
                fullMessage.Append(message);
            }

            return fullMessage.ToString();
        }

        public IAsyncEnumerable<string> GetCompletionStreamingAsync(CancellationToken cancellationToken = default)
        {
            return this._choice.GetTextStreaming(cancellationToken);
        }
    }

    internal sealed class ProxyTextCompletionResult : ITextCompletionResult
    {
        private readonly ModelResult _modelResult;
        private readonly Choice _choice;

        public ProxyTextCompletionResult(Completions resultData, Choice choice)
        {
            this._modelResult = new ModelResult(resultData);
            this._choice = choice;
        }

        public ModelResult ModelResult => this._modelResult;

        public Task<string> GetCompletionAsync(CancellationToken cancellationToken = default)
        {
            return Task.FromResult(this._choice.Text);
        }
    }

    /// <summary>
    /// Contains the values of status codes defined for HTTP in the response to an HTTP request.
    /// </summary>
    [SuppressMessage("Design", "CA1069:Enums values should not be duplicated", Justification = "<Pending>")]
    internal enum HttpStatusCodeType
    {
        /// <summary>
        /// The server has received the request headers and the client should proceed to send the request body.
        /// </summary>
        Continue = 100,

        /// <summary>
        /// The server is switching protocols according to the Upgrade header sent by the client.
        /// </summary>
        SwitchingProtocols = 101,

        /// <summary>
        /// The server is processing the request, but has not completed it yet.
        /// </summary>
        Processing = 102,

        /// <summary>
        /// The server is sending some hints about the response before the final status code.
        /// </summary>
        EarlyHints = 103,

        /// <summary>
        /// The request has succeeded and the response contains the requested resource.
        /// </summary>
        OK = 200,

        /// <summary>
        /// The request has been fulfilled and a new resource has been created.
        /// </summary>
        Created = 201,

        /// <summary>
        /// The request has been accepted for further processing, but the processing has not been completed.
        /// </summary>
        Accepted = 202,

        /// <summary>
        /// The server is returning a response from a different source than the requested one, but the response is still valid.
        /// </summary>
        NonAuthoritativeInformation = 203,

        /// <summary>
        /// The request has been successfully processed, but the server does not need to return any content.
        /// </summary>
        NoContent = 204,

        /// <summary>
        /// The server has fulfilled the request and the client should reset the document view.
        /// </summary>
        ResetContent = 205,

        /// <summary>
        /// The server is returning a partial response to a range request.
        /// </summary>
        PartialContent = 206,

        /// <summary>
        /// The server is returning a response that contains multiple status codes for different parts of the request.
        /// </summary>
        MultiStatus = 207,

        /// <summary>
        /// The server has already reported the status of the request and does not need to repeat it.
        /// </summary>
        AlreadyReported = 208,

        /// <summary>
        /// The server is returning a response that is the result of applying a delta encoding to the requested resource.
        /// </summary>
        IMUsed = 226,

        /// <summary>
        /// The requested resource has multiple representations and the client should choose one of them.
        /// </summary>
        Ambiguous = 300,

        /// <summary>
        /// The requested resource has multiple representations and the client should choose one of them.
        /// </summary>
        MultipleChoices = 300,

        /// <summary>
        /// The requested resource has been permanently moved to a new location and the client should use the new URI.
        /// </summary>
        Moved = 301,

        /// <summary>
        /// The requested resource has been permanently moved to a new location and the client should use the new URI.
        /// </summary>
        MovedPermanently = 301,

        /// <summary>
        /// The requested resource has been temporarily moved to a new location and the client should use the new URI.
        /// </summary>
        Found = 302,

        /// <summary>
        /// The requested resource has been temporarily moved to a new location and the client should use the new URI.
        /// </summary>
        Redirect = 302,

        /// <summary>
        /// The requested resource can be found at a different URI and the client should use a GET method to retrieve it.
        /// </summary>
        RedirectMethod = 303,

        /// <summary>
        /// The requested resource can be found at a different URI and the client should use a GET method to retrieve it.
        /// </summary>
        SeeOther = 303,

        /// <summary>
        /// The requested resource has not been modified since the last request and the client can use the cached version.
        /// </summary>
        NotModified = 304,

        /// <summary>
        /// The requested resource is only available through a proxy and the client should use the proxy URI.
        /// </summary>
        UseProxy = 305,

        /// <summary>
        /// This status code is no longer used and is reserved for future use.
        /// </summary>
        Unused = 306,

        /// <summary>
        /// The requested resource has been temporarily moved to a new location and the client should use the same method to access it.
        /// </summary>
        RedirectKeepVerb = 307,

        /// <summary>
        /// The requested resource has been temporarily moved to a new location and the client should use the same method to access it.
        /// </summary>
        TemporaryRedirect = 307,

        /// <summary>
        /// The requested resource has been permanently moved to a new location and the client should use the same method to access it.
        /// </summary>
        PermanentRedirect = 308,

        /// <summary>
        /// The server cannot process the request due to a malformed syntax or an invalid parameter.
        /// </summary>
        BadRequest = 400,

        /// <summary>
        /// The request requires authentication and the client should provide valid credentials.
        /// </summary>
        Unauthorized = 401,

        /// <summary>
        /// The request requires payment and the client should provide valid payment information.
        /// </summary>
        PaymentRequired = 402,

        /// <summary>
        /// The server has understood the request, but refuses to authorize it due to insufficient permissions or other reasons.
        /// </summary>
        Forbidden = 403,

        /// <summary>
        /// The server cannot find the requested resource and the client should not repeat the request.
        /// </summary>
        NotFound = 404,

        /// <summary>
        /// The server does not support the method used by the request and the client should use a different method.
        /// </summary>
        MethodNotAllowed = 405,

        /// <summary>
        /// The server cannot produce a response that matches the preferences specified by the request headers.
        /// </summary>
        NotAcceptable = 406,

        /// <summary>
        /// The request requires authentication through a proxy and the client should provide valid proxy credentials.
        /// </summary>
        ProxyAuthenticationRequired = 407,

        /// <summary>
        /// The server did not receive the complete request within the time limit and the client should try again later.
        /// </summary>
        RequestTimeout = 408,

        /// <summary>
        /// The request could not be completed due to a conflict with the current state of the resource.
        /// </summary>
        Conflict = 409,

        /// <summary>
        /// The requested resource is no longer available and the server does not know the new location.
        /// </summary>
        Gone = 410,

        /// <summary>
        /// The request requires a Content-Length header and the client should provide it.
        /// </summary>
        LengthRequired = 411,

        /// <summary>
        /// The request does not meet the preconditions specified by the request headers and the server cannot process it.
        /// </summary>
        PreconditionFailed = 412,

        /// <summary>
        /// The request entity is too large and the server cannot process it.
        /// </summary>
        RequestEntityTooLarge = 413,

        /// <summary>
        /// The request URI is too long and the server cannot process it.
        /// </summary>
        RequestUriTooLong = 414,

        /// <summary>
        /// The request entity has a media type that the server does not support or cannot handle.
        /// </summary>
        UnsupportedMediaType = 415,

        /// <summary>
        /// The request specifies a range that the server cannot satisfy or is invalid.
        /// </summary>
        RequestedRangeNotSatisfiable = 416,

        /// <summary>
        /// The request contains an Expect header that the server cannot meet or is invalid.
        /// </summary>
        ExpectationFailed = 417,

        /// <summary>
        /// The request was directed to a server that is not able to produce a response.
        /// </summary>
        MisdirectedRequest = 421,

        /// <summary>
        /// The request entity is well-formed, but cannot be processed by the server due to semantic errors.
        /// </summary>
        UnprocessableEntity = 422,

        /// <summary>
        /// The requested resource is locked and the client should release it before modifying it.
        /// </summary>
        Locked = 423,

        /// <summary>
        /// The request failed due to a dependency on another request that failed.
        /// </summary>
        FailedDependency = 424,

        /// <summary>
        /// The request requires the server to upgrade to a different protocol and the client should use the Upgrade header to specify it.
        /// </summary>
        UpgradeRequired = 426,

        /// <summary>
        /// The request requires the server to apply preconditions and the client should use the If-Match or If-Unmodified-Since headers to specify them.
        /// </summary>
        PreconditionRequired = 428,

        /// <summary>
        /// The client has sent too many requests in a given time and the server rejects them to prevent overload.
        /// </summary>
        TooManyRequests = 429,

        /// <summary>
        /// The request contains headers that are too large and the server cannot process them.
        /// </summary>
        RequestHeaderFieldsTooLarge = 431,

        /// <summary>
        /// The server is denying access to the requested resource for legal reasons and the client should not repeat the request.
        /// </summary>
        UnavailableForLegalReasons = 451,

        /// <summary>
        /// The server encountered an unexpected error and cannot fulfill the request.
        /// </summary>
        InternalServerError = 500,

        /// <summary>
        /// The server does not support the functionality required by the request and the client should not repeat the request.
        /// </summary>
        NotImplemented = 501,

        /// <summary>
        /// The server received an invalid response from an upstream server and cannot fulfill the request.
        /// </summary>
        BadGateway = 502,

        /// <summary>
        /// The server is temporarily unavailable due to maintenance or overload and the client should try again later.
        /// </summary>
        ServiceUnavailable = 503,

        /// <summary>
        /// The server did not receive a timely response from an upstream server and cannot fulfill the request.
        /// </summary>
        GatewayTimeout = 504,

        /// <summary>
        /// The server does not support the HTTP version used by the request and the client should use a different version.
        /// </summary>
        HttpVersionNotSupported = 505,

        /// <summary>
        /// The server has a configuration error and cannot negotiate a suitable representation for the requested resource.
        /// </summary>
        VariantAlsoNegotiates = 506,

        /// <summary>
        /// The server has insufficient storage space to complete the request.
        /// </summary>
        InsufficientStorage = 507,

        /// <summary>
        /// The server detected an infinite loop while processing the request.
        /// </summary>
        LoopDetected = 508,

        /// <summary>
        /// The request requires additional extensions that the server does not support or cannot handle.
        /// </summary>
        NotExtended = 510,

        /// <summary>
        /// The request requires authentication at the network level and the client should provide valid network credentials.
        /// </summary>
        NetworkAuthenticationRequired = 511,
    }
}
