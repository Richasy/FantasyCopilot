// <auto-generated/>

using System.Net.Http;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.AI.ChatCompletion;
using Microsoft.SemanticKernel.AI.Embeddings;
using Microsoft.SemanticKernel.AI.TextCompletion;
using Microsoft.SemanticKernel.Connectors.AI.OpenAI.ChatCompletion;

namespace FantasyCopilot.Services;

public static class OpenAIKernelBuilderExtensions
{
    #region Text Completion
    /// <summary>
    /// Adds the OpenAI text completion service to the list.
    /// See https://platform.openai.com/docs for service details.
    /// </summary>
    /// <param name="builder">The <see cref="KernelBuilder"/> instance</param>
    /// <param name="modelId">OpenAI model name, see https://platform.openai.com/docs/models</param>
    /// <param name="apiKey">OpenAI API key, see https://platform.openai.com/account/api-keys</param>
    /// <param name="orgId">OpenAI organization id. This is usually optional unless your account belongs to multiple organizations.</param>
    /// <param name="proxyEndpoint">Proxy Open AI endpoint.</param>
    /// <param name="serviceId">A local identifier for the given AI service</param>
    /// <param name="setAsDefault">Whether the service should be the default for its type.</param>
    /// <param name="httpClient">Custom <see cref="HttpClient"/> for HTTP requests.</param>
    /// <returns>Self instance</returns>
    public static KernelBuilder WithProxyOpenAITextCompletionService(this KernelBuilder builder,
        string modelId,
        string apiKey,
        string proxyEndpoint,
        string orgId = null,
        string serviceId = null,
        bool setAsDefault = false,
        HttpClient httpClient = null)
    {
        builder.WithAIService<ITextCompletion>(serviceId, (parameters) =>
            new ProxyOpenAITextCompletion(
                modelId,
                apiKey,
                proxyEndpoint,
                orgId,
                HttpClientProvider.GetHttpClient(parameters.Config, httpClient, parameters.Logger),
                parameters.Logger),
            setAsDefault);
        return builder;
    }

    #endregion

    #region Text Embedding
    /// <summary>
    /// Adds the OpenAI text embeddings service to the list.
    /// See https://platform.openai.com/docs for service details.
    /// </summary>
    /// <param name="builder">The <see cref="KernelBuilder"/> instance</param>
    /// <param name="modelId">OpenAI model name, see https://platform.openai.com/docs/models</param>
    /// <param name="apiKey">OpenAI API key, see https://platform.openai.com/account/api-keys</param>
    /// <param name="orgId">OpenAI organization id. This is usually optional unless your account belongs to multiple organizations.</param>
    /// <param name="proxyEndpoint">Proxy Open AI endpoint.</param>
    /// <param name="serviceId">A local identifier for the given AI service</param>
    /// <param name="setAsDefault">Whether the service should be the default for its type.</param>
    /// <param name="httpClient">Custom <see cref="HttpClient"/> for HTTP requests.</param>
    /// <returns>Self instance</returns>
    public static KernelBuilder WithProxyOpenAITextEmbeddingGenerationService(this KernelBuilder builder,
        string modelId,
        string apiKey,
        string proxyEndpoint,
        string orgId = null,
        string serviceId = null,
        bool setAsDefault = false,
        HttpClient httpClient = null)
    {
        builder.WithAIService<ITextEmbeddingGeneration>(serviceId, (parameters) =>
            new ProxyOpenAITextEmbeddingGeneration(
                modelId,
                apiKey,
                proxyEndpoint,
                orgId,
                HttpClientProvider.GetHttpClient(parameters.Config, httpClient, parameters.Logger),
                parameters.Logger),
            setAsDefault);
        return builder;
    }

    #endregion

    #region Chat Completion
    /// <summary>
    /// Adds the OpenAI ChatGPT completion service to the list.
    /// See https://platform.openai.com/docs for service details.
    /// </summary>
    /// <param name="builder">The <see cref="KernelBuilder"/> instance</param>
    /// <param name="modelId">OpenAI model name, see https://platform.openai.com/docs/models</param>
    /// <param name="apiKey">OpenAI API key, see https://platform.openai.com/account/api-keys</param>
    /// <param name="orgId">OpenAI organization id. This is usually optional unless your account belongs to multiple organizations.</param>
    /// <param name="proxyEndpoint">Proxy Open AI endpoint.</param>
    /// <param name="serviceId">A local identifier for the given AI service</param>
    /// <param name="alsoAsTextCompletion">Whether to use the service also for text completion, if supported</param>
    /// <param name="setAsDefault">Whether the service should be the default for its type.</param>
    /// <param name="httpClient">Custom <see cref="HttpClient"/> for HTTP requests.</param>
    /// <returns>Self instance</returns>
    public static KernelBuilder WithProxyOpenAIChatCompletionService(this KernelBuilder builder,
        string modelId,
        string apiKey,
        string proxyEndpoint,
        string orgId = null,
        string serviceId = null,
        bool alsoAsTextCompletion = true,
        bool setAsDefault = false,
        HttpClient httpClient = null)
    {
        ProxyOpenAIChatCompletion Factory((ILogger Logger, KernelConfig Config) parameters) => new(
            modelId,
            apiKey,
            proxyEndpoint,
            orgId,
            HttpClientProvider.GetHttpClient(parameters.Config, httpClient, parameters.Logger),
            parameters.Logger);

        builder.WithAIService<IChatCompletion>(serviceId, Factory, setAsDefault);

        // If the class implements the text completion interface, allow to use it also for semantic functions
        if (alsoAsTextCompletion && typeof(ITextCompletion).IsAssignableFrom(typeof(OpenAIChatCompletion)))
        {
            builder.WithAIService<ITextCompletion>(serviceId, Factory, setAsDefault);
        }

        return builder;
    }

    #endregion

    /// <summary>
    /// Provides functionality for retrieving instances of HttpClient.
    /// </summary>
    internal static class HttpClientProvider
    {
        /// <summary>
        /// Retrieves an instance of HttpClient.
        /// </summary>
        /// <param name="config">The kernel configuration.</param>
        /// <param name="httpClient">An optional pre-existing instance of HttpClient.</param>
        /// <param name="logger">An optional logger.</param>
        /// <returns>An instance of HttpClient.</returns>
        public static HttpClient GetHttpClient(KernelConfig config, HttpClient httpClient, ILogger logger)
        {
            if (httpClient == null)
            {
                var retryHandler = config.HttpHandlerFactory.Create(logger);
                retryHandler.InnerHandler = NonDisposableHttpClientHandler.Instance;
                return new HttpClient(retryHandler, false); // We should refrain from disposing the underlying SK default HttpClient handler as it would impact other HTTP clients that utilize the same handler.
            }

            return httpClient;
        }
    }

    /// <summary>
    /// Represents a singleton implementation of <see cref="HttpClientHandler"/> that is not disposable.
    /// </summary>
    internal sealed class NonDisposableHttpClientHandler : HttpClientHandler
    {
        /// <summary>
        /// Private constructor to prevent direct instantiation of the class.
        /// </summary>
        private NonDisposableHttpClientHandler()
        {
            this.CheckCertificateRevocationList = true;
        }

        /// <summary>
        /// Gets the singleton instance of <see cref="NonDisposableHttpClientHandler"/>.
        /// </summary>
        public static NonDisposableHttpClientHandler Instance { get; } = new NonDisposableHttpClientHandler();

        /// <summary>
        /// Disposes the underlying resources held by the <see cref="NonDisposableHttpClientHandler"/>.
        /// This implementation does nothing to prevent unintended disposal, as it may affect all references.
        /// </summary>
        /// <param name="disposing">True if called from <see cref="Dispose"/>, false if called from a finalizer.</param>
#pragma warning disable CA2215 // Dispose methods should call base class dispose
        protected override void Dispose(bool disposing)
#pragma warning restore CA2215 // Dispose methods should call base class dispose
        {
            // Do nothing if called explicitly from Dispose, as it may unintentionally affect all references.
            // The base.Dispose(disposing) is not called to avoid invoking the disposal of HttpClientHandler resources.
            // This implementation assumes that the HttpClientHandler is being used as a singleton and should not be disposed directly.
        }
    }
}
